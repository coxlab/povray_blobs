% ######################################################################################################################
%
%                    ResizeBlobRatStims_General
%         
% ######################################################################################################################
%
% This program differes from ResizeBlobRatStims and ResizeBlobRatStims_Lighting, because it uses the canonical views of
% the blobs stimuli (i.e., rotation = 0) to center all the other images. This is necessary because, if rotations about
% the x POVray axis are performed, the height of the stimuli will significantly change and, as a consequence, averaging
% all the stimuli and taking the boundaries of the resulting average will push down towards the bottom of the frame all
% the views of the stimuli with x = 0. here, differently from ResizeBlobRatStims and ResizeBlobRatStims_Lighting, the
% image size (frame) is not reduced but, instead, is kept the same as in the images originally produced by POVray (so
% all views can fit).
%
%
%   NOTE:   for the program to work the images must be grayscale !!!!!
%           If the images to convert were generated by running the PEARL script Script_StimBlob.pl that,
%           in turn, calls a POVray script, then these images are verly likely in RGB format. Therefore,
%           they must be first converted to grayscale using the Photoshop droplet "Convert to grayscale".
%
% ######################################################################################################################

function ResizeBlobRatStims_General

FlagPlotBoundaries = 1;

% Rotations
RangeView_y = -60:15:60;
N_view_y = length(RangeView_y);
RangeView_x = [-20,-15,-10,0,10,15,20]; %-10:10:10; %-15:15:15;
N_view_x = length(RangeView_x);
% Light sorce position
% RangeLight_X = [0 0 10];
% RangeLight_Y = [-10 10 0];
% RangeLight_Z = [-10 -10 -10];
% RangeLight_X = [-5];
% RangeLight_Y = [5];
% RangeLight_Z = [-10];
RangeLight_X = [0];
RangeLight_Y = [-10];
RangeLight_Z = [-10];



% =========== Find the boundaries of the image resulting from averaging all views of both stimuli ===========
IdxImg = 1;
% Loop on position of the light source
for LightPos = 1:length(RangeLight_X)
    SuffixName = ['_LighPos_x', num2str(RangeLight_X(LightPos)), '_y', num2str(RangeLight_Y(LightPos)), ...
        '_z',  num2str(RangeLight_Z(LightPos)), '.png'];
    
    % Loop on all stimuli
    for Stim = 1:2
        BaseName = ['Blob_', num2str(Stim) ,'_CamRot_y'];
        % Loop on all ViewPoints
        for v_y = RangeView_y 
            for v_x = RangeView_x

                % Load image at right viewpoint
                Image2Load = [BaseName, num2str(v_y), '_CamRot_x', num2str(v_x), SuffixName];
                [img map] = imread( Image2Load );

                % Build stack matrix with all transformaitons
                img_stack(IdxImg,:,:) = img;

                IdxImg = IdxImg+1;
            end; %for v_x
        end; %for v_y
    end; %for Stim
end; %for LightPos

%  img_av = uint8( squeeze( mean(img_stack,1) ) );
img_av = uint8( squeeze( sum(img_stack,1) ) );
figure;
image(img_av);
map=gray(256);
colormap(map);
title('Average image');

% Find image boundaries
[col_bounds_av, row_bounds_av] = FindImageBoundingBox_call( img_av, FlagPlotBoundaries );


% =========== Find the boundaries of the image resulting from averaging the canonical views of both stimuli ===========
% NOTE: with canonical we means: y rot = 0, x rot = 0
img_stack = [];
IdxImg = 1;
% Loop on position of the light source
for LightPos = 1:length(RangeLight_X)
    SuffixName = ['_LighPos_x', num2str(RangeLight_X(LightPos)), '_y', num2str(RangeLight_Y(LightPos)), ...
        '_z',  num2str(RangeLight_Z(LightPos)), '.png'];
    
    % Loop on all stimuli
    for Stim = 1:2
        BaseName = ['Blob_', num2str(Stim) ,'_CamRot_y'];
        % Loop on all ViewPoints
        for v_y = 0 
            for v_x = 0

                % Load image at right viewpoint
                Image2Load = [BaseName, num2str(v_y), '_CamRot_x', num2str(v_x), SuffixName];
                [img map] = imread( Image2Load );

                % Build stack matrix with all transformaitons
                img_stack(IdxImg,:,:) = img;

                IdxImg = IdxImg+1;
            end; %for v_x
        end; %for v_y
    end; %for Stim
end; %for LightPos

img_av = uint8( squeeze( sum(img_stack,1) ) );
figure;
image(img_av);
map=gray(256);
colormap(map);
title('Average image');

% Find image boundaries
[col_bounds_can, row_bounds_can] = FindImageBoundingBox_call( img_av, FlagPlotBoundaries );

% Decide the amount of the translation
[nrow ncol] = size(img);
Drow(1) = nrow-row_bounds_can(2);
Drow(2) = row_bounds_can(1);
TransRow = (Drow(1)-Drow(2))/2;
% Images must be translated to the top
if TransRow < 0
    disp(['Images must be translated to the TOP of ', num2str(abs(TransRow)), ' pixels']);
    % There is enough room in all the images for the required translation
    if abs(TransRow) < row_bounds_av(1)
        FlagTranslate = 1;
    else
        disp('ERROR: there is not enough room in all the images for the required translation ');
        disp('As a solution, paste first the image over a larger background');
        return;
    end;
% Images must be translated to the bottom    
else
    disp(['Images must be translated to the BOTTOM of ', num2str(abs(TransRow)), ' pixels']);
    disp(' ... exiting function: translation to the BOTTOM not yet implemented!');
    return;
end;


% =========== Translate all images of the necessary amount ==============
if FlagTranslate
    
    figure;
    % Loop on position of the light source
    for LightPos = 1:length(RangeLight_X)
        SuffixName = ['_LighPos_x', num2str(RangeLight_X(LightPos)), '_y', num2str(RangeLight_Y(LightPos)), ...
            '_z',  num2str(RangeLight_Z(LightPos)), '.png'];

        % Loop on all stimuli
        for Stim = 1:2
            BaseName = ['Blob_', num2str(Stim) ,'_CamRot_y'];
            % Loop on all ViewPoints
            for v_y = RangeView_y 
                for v_x = RangeView_x

                    % Load image at right viewpoint
                    Image2Load = [BaseName, num2str(v_y), '_CamRot_x', num2str(v_x), SuffixName];
                    [img map] = imread( Image2Load );

                    % Translate image
                    se = translate(strel(1), [TransRow 0]);
                    img_tr = imdilate(img,se);
                    
                    OutName = ['Blob_N', num2str(Stim) ,'_CamRot_y', num2str(v_y), '_CamRot_x', num2str(v_x), SuffixName];
                    imwrite( img_tr, OutName, 'png' ); 
                    imshow(img_tr);
                    drawnow;

                end; %for v_x
            end; %for v_y
        end; %for Stim
    end; %for LightPos

end; %if FlagTranslate


return;

% =========== Crop each image using the boundaries obtained above ==============
xmin = col_bounds(1)-2;
ymin = row_bounds(1)-2;
width = col_bounds(2) - col_bounds(1) +4;
height = row_bounds(2) - row_bounds(1) +4;
rect = [xmin ymin width height];

% Loop on position of the light source
for LightPos = 1:length(RangeLight_X)
    SuffixName = ['_LighPos_x', num2str(RangeLight_X(LightPos)), '_y', num2str(RangeLight_Y(LightPos)), ...
        '_z',  num2str(RangeLight_Z(LightPos)), '.png'];

    % Loop on all stimuli
    for Stim = 1:2
        BaseName = ['Blob_', num2str(Stim) ,'_CamRot_y'];
        % Loop on all ViewPoints
        for v_y = RangeView_y 
            for v_x = RangeView_x

                % Load image at right viewpoint
                Image2Load = [BaseName, num2str(v_y), '_CamRot_x', num2str(v_x), SuffixName];
                [img map] = imread( Image2Load );

                img_crop = imcrop(img,rect);
                OutName = ['Blob_N', num2str(Stim) ,'_CamRot_y', num2str(v_y), '_CamRot_x', num2str(v_x), SuffixName];
                h_f = figure;
                imshow(img_crop);
                imwrite( img_crop, OutName, 'png' ); 

                close(h_f);

            end; %for v_x
        end; %for v_y
    end; %for Stim
end; %for LightPos




