% ######################################################################################################################
%
%                    ResizeBlobRatStims_Lighting
%         
% ######################################################################################################################
%
%  Sum all the views of the blobs (Stim 1 and 2), find the boundaries, then crop each image (view) to these boundaries
%
%   NOTE:   it differes from "ResizeBlobRatStims" because it deals also with different illumination conditions of the
%           blob stimuli.
%
%   NOTE:   for the program to work the images must be grayscale !!!!!
%           If the images to convert were generated by running the PEARL script Script_StimBlob.pl that,
%           in turn, calls a POVray script, then these images are verly likely in RGB format. Therefore,
%           they must be first converted to grayscale using the Photoshop droplet "Convert to grayscale".
%
% ######################################################################################################################

function ResizeBlobRatStims_Lighting

FlagPlotBoundaries = 1;

% Rotations
RangeView = -60:15:60;
RangeView = [-90 -75 -60 -45 -30 -15 -5 0 5 15 30 45 60 75 90];
N_view = length(RangeView);
% Light sorce position
% RangeLight_X = [0 0 10];
% RangeLight_Y = [-10 10 0];
% RangeLight_Z = [-10 -10 -10];
% RangeLight_X = [-5];
% RangeLight_Y = [5];
% RangeLight_Z = [-10];
RangeLight_X = [0 ];
RangeLight_Y = [-10 ];
RangeLight_Z = [-10 ];
Suff = '_Amb0.2_Diff0.2';


% =========== Find the boundaries of the image resulting from averaging all views of both stimuli ===========
IdxImg = 1;
% Loop on position of the light source
for LightPos = 1:length(RangeLight_X)
    SuffixName = ['_LighPos_x', num2str(RangeLight_X(LightPos)), '_y', num2str(RangeLight_Y(LightPos)), ...
        '_z',  num2str(RangeLight_Z(LightPos)), Suff, '.png'];
    
    % Loop on all stimuli
    for Stim = 1:2
        BaseName = ['Blob_', num2str(Stim) ,'_CamRot_y'];
        % Loop on all ViewPoints
        for v = RangeView 

            % Load image at right viewpoint
            Image2Load = [BaseName, num2str(v), SuffixName];
            [img map] = imread( Image2Load );

            % Build stack matrix with all transformaitons
            img_stack(IdxImg,:,:) = img;

            IdxImg = IdxImg+1;
        end; %for v
    end; %for Stim
end; %for LightPos

%  img_av = uint8( squeeze( mean(img_stack,1) ) );
img_av = uint8( squeeze( sum(img_stack,1) ) );
figure;
imshow(img_av);
map=gray(256);
colormap(map);
title('Average image');

% Find image boundaries
[col_bounds, row_bounds] = FindImageBoundingBox_call( img_av, FlagPlotBoundaries );



% =========== Crop each image using the boundaries obtained above ==============
xmin = col_bounds(1)-2;
ymin = row_bounds(1)-2;
width = col_bounds(2) - col_bounds(1) +4;
height = row_bounds(2) - row_bounds(1) +4;
rect = [xmin ymin width height];

% Loop on position of the light source
for LightPos = 1:length(RangeLight_X)
    SuffixName = ['_LighPos_x', num2str(RangeLight_X(LightPos)), '_y', num2str(RangeLight_Y(LightPos)), ...
        '_z',  num2str(RangeLight_Z(LightPos)), Suff, '.png'];

    % Loop on all stimuli
    for Stim = 1:2
        BaseName = ['Blob_', num2str(Stim) ,'_CamRot_y'];
        % Loop on all ViewPoints
        for v = RangeView 

            % Load image at right viewpoint
            Image2Load = [BaseName, num2str(v), SuffixName];
            [img map] = imread( Image2Load );

            img_crop = imcrop(img,rect);
            OutName = ['Blob_N', num2str(Stim) ,'_CamRot_y', num2str(v), SuffixName];
            h_f = figure;
            imshow(img_crop);
            imwrite( img_crop, OutName, 'png' ); 

            close(h_f);

        end; %for v
    end; %for Stim
end; %for LightPos




